<!DOCTYPE html>
<html lang="en">
<head>
    <title>Visualize Vessel GPS Data</title>
    <meta property="og:description" content="A tool to visualize vessel GPS data on a map." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='https://unpkg.com/maplibre-gl@5.14.0/dist/maplibre-gl.css' />
    <script src='https://unpkg.com/maplibre-gl@5.14.0/dist/maplibre-gl.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<style>
    .map-overlay {
        font: 12px/20px 'Helvetica Neue', Arial, Helvetica, sans-serif;
        position: absolute;
        width: 50%;
        top: 0;
        left: 0;
        padding: 10px;
    }

    .map-overlay .map-overlay-inner {
        background-color: #fff;
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        border-radius: 3px;
        padding: 10px;
        margin-bottom: 10px;
    }

    .map-overlay h2 {
        line-height: 24px;
        display: block;
        margin: 0 0 10px;
    }

    .map-overlay .legend .bar {
        height: 10px;
        width: 100%;
        background: linear-gradient(to right, #fca107, #7f3121);
    }

    .map-overlay input {
        background-color: transparent;
        display: inline-block;
        width: 100%;
        position: relative;
        margin: 0;
        cursor: ew-resize;
    }
</style>
<div id="map"></div>

<div class="map-overlay top">
    <div class="map-overlay-inner" id="map-overlay-inner-id">
        <h2>Timestamps coordinates</h2>
        <label id="time" for="slider"></label>
        <input id="slider" type="range" min="0" max="" step="1" value="0" autocomplete="off" />
        <button id="play_pause_button">Play Animation</button>

        <label id="uploadButtonText">Upload CSV Files(s)</label>
        <input type="file" id="uploadFiles" accept=".csv" autocomplete="off" multiple />
    </div>
</div>

<script src="https://d3js.org/d3.v7.min.js" charset="utf-8"></script>

<script>
    const map = new maplibregl.Map({
        container: 'map',
        style: 'https://tiles.openfreemap.org/styles/bright',
        zoom: 0
    });

    function createCheckboxes(sourceId, layerId, vessel_name) {
        const container = document.getElementById('map-overlay-inner-id');
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.id = `${sourceId}_checkbox`;
        checkbox.checked = true;

        const label = document.createElement('label');
        label.htmlFor = `${sourceId}_checkbox`;
        label.textContent = vessel_name;

        container.appendChild(checkbox);
        container.appendChild(label);

        checkbox.addEventListener('change', (e) => {
            if (e.target.checked) {
                map.setLayoutProperty(layerId, 'visibility', 'visible');
            } else {
                map.setLayoutProperty(layerId, 'visibility', 'none');
            }
        });
    }

    function createColorPicker(sourceId, layerId) {
        const container = document.getElementById('map-overlay-inner-id');
        const colorPicker = document.createElement('input');
        colorPicker.type = 'color';
        colorPicker.id = `${sourceId}_colorpicker`;
        colorPicker.value = "#000000";

        container.appendChild(colorPicker);

        colorPicker.addEventListener('change', (e) => {
            map.setPaintProperty(layerId, 'line-color', e.target.value);
        });
    }

    let csvData = [];

    const data = { 
        "type": "FeatureCollection",
        "features": [
        ]
    };

    map.on('load', () => {
        
        uploadFiles.addEventListener('change', async (event) => {
            
            const files = event.target.files;
            
            for (const file of files) {
                const text = await file.text();
                const entries = d3.dsvFormat(`;`).parse(text);
                const validEntries = entries.filter(entry => entry.Latitude !== "0N" && entry.Longitude !== "0E");

                if (validEntries.length === 0) {
                    console.log(`----- No valid data in file: ${file.name}`);
                    continue;
                }

                const name2 = validEntries[0].Name2 || file.name.replace('.csv', '');
                
                const feature = { 
                    "type": "Feature",
                    "geometry": {
                        "type": "LineString",
                        "coordinates": []
                    },
                    "properties": {
                        "Name": [],
                        "Date_Time": [],
                        "Speed": [],
                        "Course": [],
                        "Sats": [],
                        "HDOP": [],
                        "CellId": [],
                        "LAC": validEntries[0].LAC,
                        "Name2": name2,
                        "TA": [],
                        "PL": [],
                        "M": [],
                        "IntPwr": [],
                        "ACC": [],
                        "Temp": [],
                        "Charging": [],
                        "RSSI": [],
                        "Mode": [],
                        "CAP": [],
                    }
                };
                
                for (const row of validEntries) {
                    // Latitude and Longitude data from CSV uses a comma (,), maplibre expects a period (.), we use the replace() function to change the comma to a period
                    // Latitude and Longitude data from CSV adds N and E at the end, with the replace() function we remove these characters
                    row.Latitude = row.Latitude.replace(/,/g, ".");
                    row.Latitude = row.Latitude.replace(/N/gi, "");
                    row.Longitude = row.Longitude.replace(/,/g, ".");
                    row.Longitude = row.Longitude.replace(/E/gi, "");

                    // Convert UTC_Date & UTC_Time rows to ISO8601 format (YYYY-MM-DDThh:mm:ss)
                    row['UTC Date'] = row['UTC Date'].split("-").reverse().join("-");

                    feature.geometry.coordinates.push([ row.Longitude, row.Latitude ]);
                    feature.properties.Name.push(row.Name);
                    feature.properties.Date_Time.push(`${row['UTC Date']}T${row['UTC Time']}.000Z`);
                    feature.properties.Speed.push(row.Speed);
                    feature.properties.Course.push(row.Course);
                    feature.properties.Sats.push(row.Sats);
                    feature.properties.HDOP.push(row.HDOP);
                    feature.properties.CellId.push(row.CellID);
                    feature.properties.TA.push(row.TA);
                    feature.properties.PL.push(row.PL);
                    feature.properties.M.push(row.M);
                    feature.properties.IntPwr.push(row.IntPwr);
                    feature.properties.ACC.push(row.ACC);
                    feature.properties.Temp.push(row.Temp);
                    feature.properties.Charging.push(row.Charging);
                    feature.properties.RSSI.push(row.RSSI);
                    feature.properties.Mode.push(row.Mode);
                    feature.properties.CAP.push(row.CAP);
                }

                data.features.push(feature);

                const sourceId = `sourceId_${name2}`;
                const layerId = `layerId_${name2}`;

                map.addSource(sourceId, {type: 'geojson', data: feature});
                map.addLayer({
                    'id': layerId,
                    'type': 'line',
                    'source': sourceId,
                    'layout': {
                        'line-cap': 'round'
                    },
                    'paint': {
                        'line-opacity': 1,
                        'line-width': 4,
                    }
                });
                createCheckboxes(sourceId, layerId, name2);
                createColorPicker(sourceId, layerId);
            }

            map.jumpTo({'center': data.features[0].geometry.coordinates[0], 'zoom': 16});

            const length = Math.max(...data.features.map(f => f.properties.Date_Time.length));
            document.getElementById("slider").max = length - 1; // -1 to avoid arrow head issue
            filterBy(0);
        });


        function createArrow(start, end, headLength = 0.0001, headAngle = Math.PI / 8) {
            const dx = end[0] - start[0];
            const dy = end[1] - start[1];
            const angle = Math.atan2(dy, dx);

            const leftX = end[0] - headLength * Math.cos(angle - headAngle);
            const leftY = end[1] - headLength * Math.sin(angle - headAngle);

            const rightX = end[0] - headLength * Math.cos(angle + headAngle);
            const rightY = end[1] - headLength * Math.sin(angle + headAngle);

            return [[leftX, leftY], [rightX, rightY]];
        }

        function filterBy(datetime_index) {
            // Set the label to the datetime value
            let datetime = new Date(data.features[0].properties.Date_Time[datetime_index]);

            document.getElementById('time').textContent = `${datetime.toUTCString()}`;
            const index = data.features[0].properties.Date_Time.findIndex((b) => b === data.features[0].properties.Date_Time[datetime_index]);

            for (let i = 0; i < data.features.length; i++) {

                const checkboxValue = document.getElementById(`sourceId_${data.features[i].properties.Name2}_checkbox`).checked;

                if (!checkboxValue) {
                    continue;
                }

                const coordinatesArray = data.features[i].geometry.coordinates;
                const arrowHeadLines = createArrow(coordinatesArray[index], coordinatesArray[index + 1]);
                map.getSource(`sourceId_${data.features[i].properties.Name2}`).setData({
                    "type": "FeatureCollection",
                    "features": [
                        {
                            "type": "Feature",
                            "geometry": {
                                "type": "LineString",
                                "coordinates": [
                                    coordinatesArray[index],
                                    // coordinatesArray[index + 1],
                                ]
                            }
                        },
                        {
                            "type": "Feature",
                            "geometry": {
                                "type": "LineString",
                                "coordinates": [
                                    coordinatesArray[index + 1],
                                    arrowHeadLines[0]
                                ]
                            }
                        },
                        {
                            "type": "Feature",
                            "geometry": {
                                "type": "LineString",
                                "coordinates": [
                                    coordinatesArray[index + 1],
                                    arrowHeadLines[1]
                                ]
                            }
                        },
                    ]
                });
            }
        }

        const slider = document.getElementById('slider');

        let current = 0;
        let timer = null;
        let isPlaying = false;

        function sliderAnimation(slider, maxIndex, interval) {
            if (isPlaying) {
                return;
            }
            isPlaying = true;

            timer = window.setInterval(() => {
                slider.value = current;
                
                slider.addEventListener('change', (e) => {
                    current = e.target.value;
                });

                slider.dispatchEvent(new Event('input'));
                current++;
                if (current > maxIndex) {
                    pause();
                    current = 0;
                }
            }, interval);

            return timer;
        }

        function pause() {
            window.clearInterval(timer);
            isPlaying = false;
        }

        function togglePlayPause() {
            const button = document.getElementById('play_pause_button');
            if (isPlaying) {
                pause();
                button.textContent = "Play Animation";
            } else {
                stopAnimation = sliderAnimation(slider, parseInt(slider.max, 10), 300);
                button.textContent = "Pause Animation";
            }
        }

        document.getElementById('play_pause_button').addEventListener('click', togglePlayPause);

        slider.addEventListener('input', (e) => {
            const timestamp = parseInt(e.target.value, 10);
            filterBy(timestamp);
        });
    });
</script>
</body>
</html>
