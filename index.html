<!DOCTYPE html>
<html lang="en">
<head>
    <title>Update a feature in realtime</title>
    <meta property="og:description" content="Change an existing feature on your map in real-time by updating its data." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='https://unpkg.com/maplibre-gl@5.14.0/dist/maplibre-gl.css' />
    <script src='https://unpkg.com/maplibre-gl@5.14.0/dist/maplibre-gl.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<style>
    .map-overlay {
        font: 12px/20px 'Helvetica Neue', Arial, Helvetica, sans-serif;
        position: absolute;
        width: 50%;
        top: 0;
        left: 0;
        padding: 10px;
    }

    .map-overlay .map-overlay-inner {
        background-color: #fff;
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        border-radius: 3px;
        padding: 10px;
        margin-bottom: 10px;
    }

    .map-overlay h2 {
        line-height: 24px;
        display: block;
        margin: 0 0 10px;
    }

    .map-overlay .legend .bar {
        height: 10px;
        width: 100%;
        background: linear-gradient(to right, #fca107, #7f3121);
    }

    .map-overlay input {
        background-color: transparent;
        display: inline-block;
        width: 100%;
        position: relative;
        margin: 0;
        cursor: ew-resize;
    }
</style>
<div id="map"></div>

<div class="map-overlay top">
    <div class="map-overlay-inner" id="map-overlay-inner-id">
        <h2>Timestamps coordinates</h2>
        <label id="time" for="slider"></label>
        <input id="slider" type="range" min="0" max="" step="1" value="0" autocomplete="off" />
        <button id="play_pause_button">Play Animation</button>

        <label id="uploadButtonText">Upload CSV Files(s)</label>
        <input type="file" id="uploadFiles" accept=".csv" multiple />
    </div>
</div>

<script src="https://d3js.org/d3.v7.min.js" charset="utf-8"></script>

<script>
    const map = new maplibregl.Map({
        container: 'map',
        style: 'https://tiles.openfreemap.org/styles/bright',
        zoom: 0
    });

    function createCheckboxes(sourceId, layerId, vessel_name) {
        const container = document.getElementById('map-overlay-inner-id');
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.id = `${sourceId}_checkbox`;
        checkbox.checked = true;

        const label = document.createElement('label');
        label.htmlFor = `${sourceId}_checkbox`;
        label.textContent = vessel_name;

        container.appendChild(checkbox);
        container.appendChild(label);

        checkbox.addEventListener('change', (e) => {
            if (e.target.checked) {
                map.setLayoutProperty(layerId, 'visibility', 'visible');
            } else {
                map.setLayoutProperty(layerId, 'visibility', 'none');
            }
        });
    }

    let csvData = [];

    uploadFiles.addEventListener('change', async (event) => {
        
        const files = event.target.files;
        
        console.log("----- Selected files: ");
        console.log(files[0]);
        
        for (const file of files) {
            const text = await file.text();
            const entries = d3.dsvFormat(`;`).parse(text);
            const validEntries = entries.filter(entry => entry.Latitude !== "0N" && entry.Longitude !== "0E");

            if (validEntries.length === 0) {
                console.log(`----- No valid data in file: ${file.name}`);
                continue;
            }

            const name2 = validEntries[0].Name2 || file.name.replace('.csv', '');
            
            const feature = { 
                "type": "Feature",
                "geometry": {
                    "type": "LineString",
                    "coordinates": []
                },
                "properties": {
                    "Name": [],
                    "Date_Time": [],
                    "Speed": [],
                    "Course": [],
                    "Sats": [],
                    "HDOP": [],
                    "CellId": [],
                    "LAC": validEntries[0].LAC,
                    "Name2": name2,
                    "TA": [],
                    "PL": [],
                    "M": [],
                    "IntPwr": [],
                    "ACC": [],
                    "Temp": [],
                    "Charging": [],
                    "RSSI": [],
                    "Mode": [],
                    "CAP": [],
                }
            };
            
            for (const row of validEntries) {
                // Latitude and Longitude data from CSV uses a comma (,), maplibre expects a period (.), we use the replace() function to change the comma to a period
                // Latitude and Longitude data from CSV adds N and E at the end, with the replace() function we remove these characters
                row.Latitude = row.Latitude.replace(/,/g, ".");
                row.Latitude = row.Latitude.replace(/N/gi, "");
                row.Longitude = row.Longitude.replace(/,/g, ".");
                row.Longitude = row.Longitude.replace(/E/gi, "");

                // Convert UTC_Date & UTC_Time rows to ISO8601 format (YYYY-MM-DDThh:mm:ss)
                row['UTC Date'] = row['UTC Date'].split("-").reverse().join("-");

                feature.geometry.coordinates.push([ row.Longitude, row.Latitude ]);
                feature.properties.Name.push(row.Name);
                feature.properties.Date_Time.push(`${row['UTC Date']}T${row['UTC Time']}.000Z`);
                feature.properties.Speed.push(row.Speed);
                feature.properties.Course.push(row.Course);
                feature.properties.Sats.push(row.Sats);
                feature.properties.HDOP.push(row.HDOP);
                feature.properties.CellId.push(row.CellID);
                feature.properties.TA.push(row.TA);
                feature.properties.PL.push(row.PL);
                feature.properties.M.push(row.M);
                feature.properties.IntPwr.push(row.IntPwr);
                feature.properties.ACC.push(row.ACC);
                feature.properties.Temp.push(row.Temp);
                feature.properties.Charging.push(row.Charging);
                feature.properties.RSSI.push(row.RSSI);
                feature.properties.Mode.push(row.Mode);
                feature.properties.CAP.push(row.CAP);

                console.log("----- Processed row: ", feature);
            }

            const randomColor = "#000000".replace(/0/g,function() {
                return (~~(Math.random()*16)).toString(16);
            });

            data.features.push(feature);
            const sourceId = `sourceId_${name2}`;
            const layerId = `layerId_${name2}`;
            // to do create color picker
            map.addSource(sourceId, {type: 'geojson', data: feature});
            map.addLayer({
                'id': layerId,
                'type': 'line',
                'source': sourceId,
                'layout': {
                    'line-cap': 'round'
                },
                'paint': {
                    'line-color': randomColor,
                    'line-opacity': 1,
                    'line-width': 4,
                }
            });
            createCheckboxes(sourceId, layerId, name2);
        }
        filterby(0);
    });

    const url = window.location.href.replace('?','');

    

    d3.dsv(`;`, `${url}`, (rawData) => {
        csvData.push(rawData);
    });

    map.on('load', () => {      

        const data = { 
            "type": "FeatureCollection",
            "features": [
            ]
        };
        
        let container = {};
        let csv_index = csvData.length;

        while (csv_index--) {
            if (csvData[csv_index].Latitude === "0N" && csvData[csv_index].Longitude === "0E") { 
                csvData.splice(csv_index, 1);
            }
        }

        for(let i = 0; i < csvData.length; i++) {
            const row = csvData[i];

            if(container[row.Name2] === undefined) {

                container[row.Name2] = {
                    "type": "Feature",
                    "geometry": {
                        "type": "LineString",
                        "coordinates": []
                    },
                    "properties": {
                        "Name": [],
                        "Date_Time": [],
                        "Speed": [],
                        "Course": [],
                        "Sats": [],
                        "HDOP": [],
                        "CellId": [],
                        "LAC": row.LAC,
                        "Name2": row.Name2,
                        "TA": [],
                        "PL": [],
                        "M": [],
                        "IntPwr": [],
                        "ACC": [],
                        "Temp": [],
                        "Charging": [],
                        "RSSI": [],
                        "Mode": [],
                        "CAP": [],
                    }
                };
            }

            // Latitude and Longitude data from CSV uses a comma (,), maplibre expects a period (.), we use the replace() function to change the comma to a period
            // Latitude and Longitude data from CSV adds N and E at the end, with the replace() function we remove these characters
            row.Latitude = row.Latitude.replace(/,/g, ".");
            row.Latitude = row.Latitude.replace(/N/gi, "");
            row.Longitude = row.Longitude.replace(/,/g, ".");
            row.Longitude = row.Longitude.replace(/E/gi, "");

            // Convert UTC_Date & UTC_Time rows to ISO8601 format (YYYY-MM-DDThh:mm:ss)
            row['UTC Date'] = row['UTC Date'].split("-").reverse().join("-");

            container[row.Name2].geometry.coordinates.push([ row.Longitude, row.Latitude ]);
            container[row.Name2].properties.Name.push(row.Name);
            container[row.Name2].properties.Date_Time.push(`${row['UTC Date']}T${row['UTC Time']}.000Z`);
            container[row.Name2].properties.Speed.push(row.Speed);
            container[row.Name2].properties.Course.push(row.Course);
            container[row.Name2].properties.Sats.push(row.Sats);
            container[row.Name2].properties.HDOP.push(row.HDOP);
            container[row.Name2].properties.CellId.push(row.CellID);
            container[row.Name2].properties.TA.push(row.TA);
            container[row.Name2].properties.PL.push(row.PL);
            container[row.Name2].properties.M.push(row.M);
            container[row.Name2].properties.IntPwr.push(row.IntPwr);
            container[row.Name2].properties.ACC.push(row.ACC);
            container[row.Name2].properties.Temp.push(row.Temp);
            container[row.Name2].properties.Charging.push(row.Charging);
            container[row.Name2].properties.RSSI.push(row.RSSI);
            container[row.Name2].properties.Mode.push(row.Mode);
            container[row.Name2].properties.CAP.push(row.CAP);
        }

        console.log("----- Start My Data: ");
        console.log(container);
        console.log("----- End My Data: ");

        for(const c in container) {
            data.features.push(container[c]);
            const sourceId = `sourceId_${c}`;
            const layerId = `layerId_${c}`;

            createCheckboxes(sourceId, layerId, container[c].properties.Name2);

            const randomColor = "#000000".replace(/0/g,function() {
                return (~~(Math.random()*16)).toString(16);
            });

            map.addSource(sourceId, {type: 'geojson', data: container[c]});
            map.addLayer({
                'id': layerId,
                'type': 'line',
                'source': sourceId,
                'layout': {
                    'line-cap': 'round'
                },
                'paint': {
                    'line-color': randomColor,
                    'line-opacity': 1,
                    'line-width': 4,
                }
            });
        }

        document.getElementById("slider").max = data.features[0].properties.Date_Time.length - 1;

        function createArrow(start, end, headLength = 0.0001, headAngle = Math.PI / 5) {
            const dx = end[0] - start[0];
            const dy = end[1] - start[1];
            const angle = Math.atan2(dy, dx);

            const leftX = end[0] - headLength * Math.cos(angle - headAngle);
            const leftY = end[1] - headLength * Math.sin(angle - headAngle);

            const rightX = end[0] - headLength * Math.cos(angle + headAngle);
            const rightY = end[1] - headLength * Math.sin(angle + headAngle);

            return [[leftX, leftY], [rightX, rightY]];
        }

        function filterBy(datetime_index) {
            const filters = ['==', 'time', datetime_index];

            // Set the label to the datetime value
            let datetime = new Date(data.features[0].properties.Date_Time[datetime_index]);

            document.getElementById('time').textContent = `${datetime.toUTCString()}`;
            const index = data.features[0].properties.Date_Time.findIndex((b) => b === data.features[0].properties.Date_Time[datetime_index]);

            for (let i = 0; i < data.features.length; i++) {

                const checkboxValue = document.getElementById(`sourceId_${data.features[0].properties.Name2}_checkbox`).checked;

                if (!checkboxValue) {
                    continue;
                }

                const coordinatesArray = data.features[i].geometry.coordinates;
                const arrowHeadLines = createArrow(coordinatesArray[index], coordinatesArray[index + 1]);
                map.getSource(`sourceId_${data.features[i].properties.Name2}`).setData({
                    "type": "FeatureCollection",
                    "features": [
                        {
                            "type": "Feature",
                            "geometry": {
                                "type": "LineString",
                                "coordinates": [
                                    coordinatesArray[index],
                                    coordinatesArray[index + 1],
                                ]
                            }
                        },
                        {
                            "type": "Feature",
                            "geometry": {
                                "type": "LineString",
                                "coordinates": [
                                    coordinatesArray[index + 1],
                                    arrowHeadLines[0]
                                ]
                            }
                        },
                        {
                            "type": "Feature",
                            "geometry": {
                                "type": "LineString",
                                "coordinates": [
                                    coordinatesArray[index + 1],
                                    arrowHeadLines[1]
                                ]
                            }
                        },
                    ]
                });
            }
        }

        filterBy(0);

        const slider = document.getElementById('slider');
        let current = 0;
        let timer = null;
        let isPlaying = false;

        function sliderAnimation(slider, maxIndex, interval) {
            if (isPlaying) {
                return;
            }
            isPlaying = true;

            timer = window.setInterval(() => {
                slider.value = current;
                slider.dispatchEvent(new Event('input'));
                current++;
                if (current > maxIndex) {
                    pause();
                    current = 0;
                }
            }, interval);

            return timer;
        }

        function pause() {
            window.clearInterval(timer);
            isPlaying = false;
        }

        function togglePlayPause() {
            const button = document.getElementById('play_pause_button');
            if (isPlaying) {
                pause();
                button.textContent = "Play Animation";
            } else {
                stopAnimation = sliderAnimation(slider, parseInt(slider.max, 10), 500);
                button.textContent = "Pause Animation";
            }
        }

        document.getElementById('play_pause_button').addEventListener('click', togglePlayPause);

        // const stopAnimation = sliderAnimation(slider, 7000, 500);



        slider
            .addEventListener('input', (e) => {
                const timestamp = parseInt(e.target.value, 10);
                // console.log("Slider timestamp: " + e.target.value);

                filterBy(timestamp);
                // sliderAnimation(timestamp);
            });

            


        map.jumpTo({'center': data.features[0].geometry.coordinates[0], 'zoom': 14});
    });
</script>
</body>
</html>
