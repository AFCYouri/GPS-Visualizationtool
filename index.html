<!DOCTYPE html>
<html lang="en">
    <head>
        <title>Visualize Vessel GPS Data</title>
        <meta property="og:description" content="A tool to visualize vessel GPS data on a map." />
        <meta charset='utf-8'>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel='stylesheet' href='https://unpkg.com/maplibre-gl@5.14.0/dist/maplibre-gl.css' />
        <script src='https://unpkg.com/maplibre-gl@5.16.0/dist/maplibre-gl.js'></script>
        <style>
            body { margin: 0; padding: 0; }
            html, body, #map { height: 100%; }
        </style>
    </head>
    <body>
        <style>
            .map-overlay {
                font: 12px/20px 'Helvetica Neue', Arial, Helvetica, sans-serif;
            }

            .map-overlay .map-overlay-inner {
                background-color: #fff;
                box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
                border-radius: 3px;
                padding: 10px;
                margin-bottom: 10px;
            }

            .map-overlay  h2 {
                line-height: 24px;
                display: block;
                margin: 0 0 10px;
            }

            .map-overlay .legend .bar {
                height: 10px;
                width: 100%;
                background: linear-gradient(to right, #fca107, #7f3121);
            }

            .map-overlay input [type="range"] {
                background-color: transparent;
                width: 100%;
                cursor: ew-resize;
            }
            .maplibregl-popup {
                max-width: 400px;
                font: 12px/20px 'Helvetica Neue', Arial, Helvetica, sans-serif;
            }
        </style>

        <div id="map"></div>
        <div class="absolute top-0 left-0 w-full items-center gap-3 p-4 ">
            <div class="map-overlay-inner max-w-1/4 flex flex-row items-center place-content-between gap-3 p-4 mb-1 border rounded-lg bg-gray-50">
                <h2 class="text-lg font-bold">Visualize Vessel GPS Data</h2>
                <label for="uploadFiles" class="px-4 py-3 bg-blue-950 hover:bg-blue-800 text-white rounded shadow cursor-pointer">
                    Open CSV File(s)
                </label>
                <input type="file" id="uploadFiles" accept=".csv" multiple class="hidden" />
            </div>

            <div id="vessel_controls" class="max-w-1/3 space-y-1"></div>
        </div>

        <div id="map-overlay-bottom" class="absolute bottom-0 left-0 w-full items-center gap-3 p-4 pb-10 hidden">
            <div class="map-overlay-inner flex flex-row items-center gap-3 p-4 border rounded-lg bg-gray-50">
                <div class="grid w-1/6 gap-0">
                    <label class="text-lg font-bold">Date & Time</label>
                    <label id="time" for="slider" class="block text-left text-sm font-medium text-gray-700"></label>
                </div>
                <button id="play_pause_button" class="px-4 py-2 bg-blue-950 hover:bg-blue-800 text-white rounded shadow cursor-pointer">
                    Play Scenario
                </button>
                <input id="slider" type="range" min="0" max="" step="1" value="0" class="w-full cursor-pointer" autocomplete="off"/>
            </div>
        </div>

        <script src="https://d3js.org/d3.v7.min.js" charset="utf-8"></script>
        <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>

        <script>
            const map = new maplibregl.Map({
                container: 'map',
                style: 'https://tiles.openfreemap.org/styles/bright',
                zoom: 0
            });

            function createVesselControls(sourceId, layerId, file_name) {
                const container = document.getElementById('vessel_controls');
                const row = document.createElement('div');
                row.className = 'flex items-center gap-4 p-2 border rounded bg-white shadow';
                
                // overflow-hidden text-ellipsis
                row.innerHTML = `
                    <span class="text-sm font-medium flex-1 wrap-anywhere">${file_name}</span>
                    <label class="flex items-center gap-2 flex-none">
                        <input type="checkbox" class="w-4 h-4 text-blue-950 flex-none cursor-pointer" id="${sourceId}_checkbox" checked>
                        <span class="text-sm flex-none">Show</span>
                    </label>
                    <button id="${sourceId}_fly_to_button" class="px-4 py-2 bg-blue-950 hover:bg-blue-800 text-white rounded shadow flex-none cursor-pointer">
                        Fly To
                    </button>
                    <input type="color" id="${sourceId}_colorpicker" class="w-10 h-10 p-1 border rounded cursor-pointer flex-none""></input>
                `;
                container.appendChild(row);
                
                document.getElementById(`${sourceId}_checkbox`).addEventListener('change', (e) => {
                    if (e.target.checked) {
                        map.setLayoutProperty(layerId, 'visibility', 'visible');
                    } else {
                        map.setLayoutProperty(layerId, 'visibility', 'none');
                    }
                });

                document.getElementById(`${sourceId}_colorpicker`).addEventListener('change', (e) => {
                    map.setPaintProperty(layerId, 'line-color', e.target.value);
                });
            }

            const data = { 
                "type": "FeatureCollection",
                "features": [
                ]
            };

            map.on('load', () => {
                let features_index = 0;
                
                uploadFiles.addEventListener('change', async (event) => {
                    
                    const files = event.target.files;
                    
                    for (const file of files) {
                        const text = await file.text();
                        const entries = d3.dsvFormat(`;`).parse(text);
                        const validEntries = entries.filter(entry => entry.Latitude !== "0N" && entry.Longitude !== "0E");

                        if (validEntries.length === 0) {
                            console.log(`----- No valid data in file: ${file.name}`);
                            continue;
                        }

                        const name2 = validEntries[0].Name2 || file.name.replace('.csv', '');
                        
                        const feature = { 
                            "type": "Feature",
                            "geometry": {
                                "type": "LineString",
                                "coordinates": []
                            },
                            "properties": {
                                "Filename": file.name,
                                "Name": [],
                                "Date_Time": [],
                                "Speed": [],
                                "Course": [],
                                "Sats": [],
                                "HDOP": [],
                                "CellId": [],
                                "LAC": validEntries[0].LAC,
                                "Name2": name2,
                                "TA": [],
                                "PL": [],
                                "M": [],
                                "IntPwr": [],
                                "ACC": [],
                                "Temp": [],
                                "Charging": [],
                                "RSSI": [],
                                "Mode": [],
                                "CAP": [],
                            }
                        };
                        
                        for (const row of validEntries) {
                            // Latitude and Longitude data from CSV uses a comma (,), maplibre expects a period (.), we use the replace() function to change the comma to a period
                            // Latitude and Longitude data from CSV adds N and E at the end, with the replace() function we remove these characters
                            row.Latitude = row.Latitude.replace(/,/g, ".");
                            row.Latitude = row.Latitude.replace(/N/gi, "");
                            row.Longitude = row.Longitude.replace(/,/g, ".");
                            row.Longitude = row.Longitude.replace(/E/gi, "");

                            // Convert UTC_Date & UTC_Time rows to ISO8601 format (YYYY-MM-DDThh:mm:ss)
                            row['UTC Date'] = row['UTC Date'].split("-").reverse().join("-");

                            feature.geometry.coordinates.push([ row.Longitude, row.Latitude ]);
                            feature.properties.Name.push(row.Name);
                            feature.properties.Date_Time.push(`${row['UTC Date']}T${row['UTC Time']}.000Z`);
                            feature.properties.Speed.push(row.Speed);
                            feature.properties.Course.push(row.Course);
                            feature.properties.Sats.push(row.Sats);
                            feature.properties.HDOP.push(row.HDOP);
                            feature.properties.CellId.push(row.CellID);
                            feature.properties.TA.push(row.TA);
                            feature.properties.PL.push(row.PL);
                            feature.properties.M.push(row.M);
                            feature.properties.IntPwr.push(row.IntPwr);
                            feature.properties.ACC.push(row.ACC);
                            feature.properties.Temp.push(row.Temp);
                            feature.properties.Charging.push(row.Charging);
                            feature.properties.RSSI.push(row.RSSI);
                            feature.properties.Mode.push(row.Mode);
                            feature.properties.CAP.push(row.CAP);
                        }

                        data.features.push(feature);

                        const sourceId = `sourceId_${name2}`;
                        const layerId = `layerId_${name2}`;

                        map.addSource(sourceId, {type: 'geojson', data: feature});
                        map.addLayer({
                            'id': layerId,
                            'type': 'line',
                            'source': sourceId,
                            'layout': {
                                'line-cap': 'round'
                            },
                            'paint': {
                                'line-opacity': 1,
                                'line-width': 7,
                            }
                        });

                        createVesselControls(sourceId, layerId, file.name);
                    }

                    map.jumpTo({'center': data.features[0].geometry.coordinates[0], 'zoom': 16});

                    const length = Math.max(...data.features.map(f => f.properties.Date_Time.length));
                    document.getElementById("slider").max = length - 1; // -1 to avoid arrow head issue

                    for (const feature of data.features) {
                        if (length == feature.properties.Date_Time.length) {
                            features_index = data.features.indexOf(feature);
                        }
                    }

                    document.getElementById('map-overlay-bottom').classList.remove('hidden');

                    filterBy(0, features_index);
                });

                function createArrow(start, end, headLength = 0.0001, headAngle = Math.PI / 8) {
                    const dx = end[0] - start[0];
                    const dy = end[1] - start[1];
                    const angle = Math.atan2(dy, dx);

                    const leftX = end[0] - headLength * Math.cos(angle - headAngle);
                    const leftY = end[1] - headLength * Math.sin(angle - headAngle);

                    const rightX = end[0] - headLength * Math.cos(angle + headAngle);
                    const rightY = end[1] - headLength * Math.sin(angle + headAngle);

                    return [[leftX, leftY], [rightX, rightY]];
                }

                function filterBy(slider_index, features_index) {
                    // Set the label to the datetime value
                    let datetime = new Date(data.features[features_index].properties.Date_Time[slider_index]);

                    document.getElementById('time').textContent = `${datetime.toUTCString()}`;
                    const index = data.features[features_index].properties.Date_Time.findIndex((b) => b === data.features[features_index].properties.Date_Time[slider_index]);

                    for (let i = 0; i < data.features.length; i++) {

                        const checkboxValue = document.getElementById(`sourceId_${data.features[i].properties.Name2}_checkbox`).checked;

                        if (!checkboxValue) {
                            continue;
                        }

                        const coordinatesArray = data.features[i].geometry.coordinates;
                        const arrowHeadLines = createArrow(coordinatesArray[index], coordinatesArray[index + 1]);

                        if (index >= coordinatesArray.length - 1) {
                            return;
                        }

                        const totalSegments = 10;
                        const startIndex = Math.max(0, index - totalSegments);
                        const segmentCoordinates = coordinatesArray.slice(startIndex, index + 1);

                        console.log(`Segment coordinates for ${data.features[i].properties.Name2}:`, segmentCoordinates);

                        const button = document.getElementById(`sourceId_${data.features[i].properties.Name2}_fly_to_button`);
                        button.addEventListener('click', () => {
                            map.flyTo({center: coordinatesArray[index], zoom: 17.5});
                        });

                        layerId = `layerId_${data.features[i].properties.Name2}`;
                        map.on('click', layerId, (e) => {
                            const coordinates = segmentCoordinates[0].slice();
                            const speed = data.features[i].properties.Speed[index];
                            const course = data.features[i].properties.Course[index];

                            console.log(`Clicked feature properties for ${data.features[i].properties.Name2} with speed: ${speed} and course: ${course}`);

                            // console.log(JSON.stringify(e.features[i].properties));

                            // Ensure that if the map is zoomed out such that multiple
                            // copies of the feature are visible, the popup appears
                            // over the copy being pointed to.
                            while (Math.abs(e.lngLat.lng - coordinates[0]) > 180) {
                                coordinates[0] += e.lngLat.lng > coordinates[0] ? 360 : -360;
                            }

                            new maplibregl.Popup()
                                .setLngLat(coordinates)
                                .setHTML(speed && course ? `<strong>${feature.properties.Filename}</strong><br><strong>Speed:</strong> ${speed} knots<br><strong>Course:</strong> ${course}Â°` : `<strong>No speed or course data available</strong>`)
                                .addTo(map);
                        });

                        map.on('mouseenter', layerId, () => {
                            map.getCanvas().style.cursor = 'pointer';
                        });

                        map.on('mouseleave', layerId, () => {
                            map.getCanvas().style.cursor = '';
                        });

                        map.getSource(`sourceId_${data.features[i].properties.Name2}`).setData({
                            "type": "FeatureCollection",
                            "features": [
                                {
                                    "type": "Feature",
                                    "geometry": {
                                        "type": "LineString",
                                        "coordinates":
                                            segmentCoordinates,
                                    },
                                },
                                {
                                    "type": "Feature",
                                    "geometry": {
                                        "type": "LineString",
                                        "coordinates": [
                                            coordinatesArray[index + 1],
                                            arrowHeadLines[0]
                                        ]
                                    },
                                },
                                {
                                    "type": "Feature",
                                    "geometry": {
                                        "type": "LineString",
                                        "coordinates": [
                                            coordinatesArray[index + 1],
                                            arrowHeadLines[1]
                                        ]
                                    },
                                },
                            ]
                        });
                    }
                }

                const slider = document.getElementById('slider');
                slider.addEventListener('change', (e) => {
                    current = e.target.value;
                });

                let current = 0;
                let timer = null;
                let isPlaying = false;

                function sliderAnimation(slider, maxIndex, interval) {
                    if (isPlaying) {
                        return;
                    }
                    isPlaying = true;

                    timer = window.setInterval(() => {
                        slider.value = current;

                        slider.dispatchEvent(new Event('input'));
                        current++;
                        if (current > maxIndex) {
                            pause();
                            current = 0;
                        }
                    }, interval);

                    return timer;
                }

                function pause() {
                    window.clearInterval(timer);
                    isPlaying = false;
                }

                function togglePlayPause() {
                    const button = document.getElementById('play_pause_button');
                    if (isPlaying) {
                        pause();
                        button.textContent = "Play Scenario";
                    } else {
                        stopAnimation = sliderAnimation(slider, parseInt(slider.max, 10), 300);
                        button.textContent = "Pause Scenario";
                    }
                }

                document.getElementById('play_pause_button').addEventListener('click', togglePlayPause);

                slider.addEventListener('input', (e) => {
                    const timestamp = parseInt(e.target.value, 10);
                    filterBy(timestamp, features_index);
                });
            });
        </script>
    </body>
</html>
